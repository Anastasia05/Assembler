.data
    sentence_p: .space 0x8		// Здесь будет указатель на начало предложения
    word_counter: .long 0x0		// Здесь будет кол-во слов
    symbol_counter: .long 0x0	// Здесь будет кол-во символов в очередном слове

.text

.globl numberwords
.type numberwords, @function

.globl numbersymbols
.type numbersymbols, @function

numberwords:

	/* В ассемблере на 64-разрядной линукс заведено так, что первый аргумент функции кладётся в rdi, второй в esi (скину скрин где написано про остальные) */
	
    movq %rdi, sentence_p		// Кладём первый аргумент - указатель на первый элемент массива-предложения - в специальную для этого переменную

    movl sentence_p, %ebx		// Перекладываем 4 байта из переменной в регистр ebx, потому что с регистром удобнее работать. 4, потому что С передаёт 4-разрядный адрес

    cycle:

            movb (%ebx), %dh	// Кладём первый символ в dh
            cmp $0x20, %dh		// Узнаём, а не является ли код этого символа кодом пробела случайно

            jne continue		// Если НЕ является, переходим к метке continue

            add $0x1, word_counter	// Если всё-таки равняется, значит очередное слово закончилсь, а значит надо нарастить счётчик слов, что и делаем

        continue:

            add $0x1, %ebx		// Завершаем цикл. Наращиваем регистр с указателем на 1, чтобы начал указывать на следующий элемент
            cmp $0x0, (%ebx)	// Проверяем, а не является ли следующий элемент концом строки
            jne cycle			// Если НЕ является, переходим к следующей итерации цикла

    add $0x1, word_counter		// Если же дошли до конца строки, докидываем ещё единичку в счётчик слов, т.к. в нём сейчас кол-во пробелов, а кол-во слов = кол-во пробелов + 1
    movl word_counter, %eax 	// Опять же, в данном конкретном ассемблере (см заголовок) заведено так, что возвращаемое значение функции кладётся в eax. Кладём туда получившееся кол-во слов.
    
    ret


numbersymbols:
    
    movq %rdi, sentence_p		// Снова загружаем указатель на начало предложения в переменную

    movl sentence_p, %ebx		// А из переменной в регистр

    cycle1:

			/* Снова кладём в dh и проверяем, а не пробел ли это */
            movb (%ebx), %dh	
            cmp $0x20, %dh

            jne continue1		// Если не пробел, переходим к завершению цикла (где наращивается счётчик символов)

            movl symbol_counter, %ecx	// Если всё же пробел, счётчик символов кладём в регистр
            movl %ecx, (%rsi)			// Потом из регистра перекладываем туда, куда указывает указатель на массив с количествами символов в каждом слове, т.е. заполняем очередной элемент этого массива 
										// очередным значением счётчика
			
            add $0x4, %rsi				// Наращиваем указатель на массив с кол-вами символов на 4, т.к. в нём значения типа int, а они по 4 байта, и следовательно, чтобы указать на следующий элемент надо прыгать через 4
            movl $0x0, symbol_counter	// Обнуляем счётчик символов очередного слова

            jmp after_space				// Прыгаем на метку "после пробела"
            

        continue1:

            add $0x1, symbol_counter	// Наращиваем счётчик символов, если был не пробел

        after_space:

            add $0x1, %ebx				// Наращеваем указатель на очередной символ предложения, чтобы перейти к следующему
            cmp $0x0, (%ebx)			// Смотрим, а не конец ли это строки
            jne cycle1					// Если не конец, переходим к следующей итерации

			/* Если всё-таки конец, отнимаем от последнего кол-ва символов единичку, потому что в коде есть баг, который кол-во символов последнего слова считает больше на единицу
				(захватывает символ конца строки). Проще отнять в конце единичку, чем исправить баг. */
            sub $0x1, symbol_counter
			
			/* Как уже делали, кладём в очередной (на этот раз последний) элемент массива значение кол-ва символов в последнем слове */
            movl symbol_counter, %ecx
            movl %ecx, (%rsi)			
    
    ret
